var Promise = require('bluebird'),
    stream = require('stream'),
    keys = require('./keys.json'),
    cursor_keys = require('./cursor_keys.json');

// Creates a lazy cursor that executes methods when connected
// returning promises for everything except `.stream()` and `.pipe`
function cursor(action) {
  function next(key) {
    return function() {
      return action.then(cur => cur[key].apply(c,arguments));
    };
  }

  var obj = cursor_keys.reduce( (p,key) => {
    p[key] = next(key);
    return p;
  },{
    
  });

  obj.stream = function() {
    var s = new stream.PassThrough({objectMode:true});
    action.then(cur => cur.pipe(s));
    return s;
  };

  obj.pipe = d => action.then(cur => cur.pipe(d)) && d;
  
  return obj;
}


// Populates incoming data based on __populate definitions
function populate(__populate) {
  return function(d) {
    if (!__populate.length)
      return d;
    __populate.forEach(p => {
      d[p.field] = p.collection.findOne({_id:d[p.field]},p.select);
    });
    return Promise.props(d);
  };
}

// Creates a lazy collection that executes methods when connected
function collection(col,options) {
  var c = this.__connected.promise.then(db => db.collection(col)),
      self = this;

  function then(key) {
    return function() {
      var action = c.then(c => c[key].apply(c,arguments));

      // Return a cursor object for find
      if (key === 'find')
        return cursor(action,obj.__populate);
      else if (key === 'findOne') {
        var __populate;
        var o = action.then(populate(__populate,self.collection.bind(self)));
        o.populate = function(field, collection, _select) {
          __populate = (__populate || []).concat({
            field: field,
            collection: self.collection(collection),
            select: _select
          });
          return o;
        };
        return o;
      }
      else
        return action;
    };
  }

  var obj = keys.reduce(function(p,key) {
    p[key] = then(key);
    return p;
  },{});

  obj.__populate = [];

  return obj;
}

module.exports = Object.create({
  collection : function(col,options) {
    if (this.__collections[col]) {
      if (options) 
        throw new Error('Options already set');
      return this.__collections[col];
    }
    var obj = collection.call(this,col,options);
    if (options) this.__collections[col] = obj;
    return obj;
  },
  connect : function() {
    var mongodb = this.mongodb || require('mongodb');
    return mongodb.connect.apply(mongodb,arguments)
      .then(db => this.__connected.resolve(db));
  }
},{
  __connected : { value : Promise.defer() },
  __collections: { value: {}}
});


var moongoose = module.exports;


var etl = require('etl')

moongoose.connect('mongodb://localhost:27017/embark2').then(console.log);
moongoose.collection('applications')
  .findOne()
  .populate('institution','institutions',{name: 1})
  .then(console.log,e => console.log(e,e.stack));
  //.pipe(etl.map(console.log));
